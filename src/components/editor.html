<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Page Editor</title>
  <script src="https://unpkg.com/tiny-markdown-editor/dist/tiny-mde.min.js"></script>
  <link
    rel="stylesheet"
    type="text/css"
    href="https://unpkg.com/tiny-markdown-editor/dist/tiny-mde.min.css"
  />
</head>
<main>
  <div>
    <button class="btn btn-soft btn-accent" onclick="handleNew()">New</button>
    <button class="btn btn-soft btn-accent" onclick="handleSave()">Save</button>
    <button class="btn btn-soft btn-accent" onclick="handlePublish()">
      Publish
    </button>
    <button class="btn btn-soft btn-accent" onclick="handleUnpublish()">
      Unpublish
    </button>
    <button class="btn btn-soft btn-accent" onclick="handleDelete()">
      Delete
    </button>
  </div>
  <h1>URL: <span id="urlLabel"></span></h1>
  <div id="toolbar"></div>
  <div id="editor"></div>
  <textarea id="txt">{contents}</textarea>
</main>
<script type="text/javascript">
  var tinyMDE = new TinyMDE.Editor({
    //   element: "editor",
    textarea: "txt",
  });
  var commandBar = new TinyMDE.CommandBar({
    element: "toolbar",
    editor: tinyMDE,
    commands: [
      "bold",
      "italic",
      "strikethrough",
      "|",
      "code",
      "|",
      "h1",
      "h2",
      "|",
      "ul",
      "ol",
      "|",
      "blockquote",
      "hr",
      "|",
      "insertLink",
      "insertImage",
    ],
  });
</script>

<script>
  const params = new URLSearchParams(document.location.search);
  async function updateContent() {
    const resp = await window.fetch(`/data?url=${params.get("url")}`);
    const data = await resp.json();
    tinyMDE.setContent(data.content);
  }

  const urlLabel = document.getElementById("urlLabel");
  urlLabel.innerText = params.get("url");
  updateContent();
  const nav = document.getElementById("nav_container");
  nav.style.visibility = "hidden";
</script>
<script>
  async function handleSave() {
    if (window.confirm("Overwrite existing content?")) {
      await window.fetch("/create", {
        headers: { "content-type": "application/json" },
        method: "POST",
        body: JSON.stringify({
          url: params.get("url"),
          content: tinyMDE.getContent(),
        }),
      });
    }
  }

  async function handleNew() {
    let url = window.prompt("Enter new URL:");
    const urlPattern = /^\/.*/;
    if (!urlPattern.test(url)) {
      alert(
        "Invalid URL:\nAllowed pattern examples include '/pagename', '/this123/more-text', etc."
      );
      return;
    }

    const res = await window.fetch(`/data?url=${url}`).then(async (res) => {
      const body = await res.json();
      return body;
    });
    if (!res) {
      await window
        .fetch("/create", {
          headers: { "content-type": "application/json" },
          method: "POST",
          body: JSON.stringify({
            url: url,
            content: "# Page Title\nWelcome to your new page.",
          }),
        })
        .then((res) => {
          window.location.assign(`/editor?url=${url}`);
        });
    } else {
      await alert("Page already exists.\nRerouting to existing content.");
      window.location.assign(`/editor?url=${url}`);
    }
  }
  async function handleDelete() {
    if (window.confirm("Delete content?\nThis cannot be undone.")) {
      const params = new URLSearchParams(document.location.search);

      const pageData = await window
        .fetch(`/data?url=${params.get("url")}`)
        .then(async (res) => {
          const body = await res.json();
          return body;
        });

      if (pageData.published) {
        alert("Cannot delete published content.");
        return;
      }

      await window
        .fetch(`/delete`, {
          headers: { "content-type": "application/json" },
          method: "DELETE",
          body: JSON.stringify({
            url: params.get("url"),
          }),
        })
        .then(() => {
          alert("Content deleted.");
          window.location.assign("/");
        });
    }
  }
  async function handlePublish() {
    if (window.confirm("Publish page?")) {
      const params = new URLSearchParams(document.location.search);
      await window
        .fetch(`/build?url=${params.get("url")}`, { method: "POST" })
        .then(async (res) => {
          const resBody = await res.json();
          if (resBody.status === "success") {
            alert("Page published successfully.");
          } else {
            throw resBody.message;
          }
        })
        .catch((err) => {
          console.error(err);
          alert("Failed to publish page. See console.");
        });
    }
  }
  async function handleUnpublish() {
    if (window.confirm("Unpublish page?")) {
      const params = new URLSearchParams(document.location.search);
      await window
        .fetch(`/unbuild?url=${params.get("url")}`, { method: "PUT" })
        .then(async (res) => {
          const resBody = await res.json();
          if (resBody.status === "success") {
            alert("Page unpublished successfully.");
          } else {
            throw resBody.message;
          }
        })
        .catch((err) => {
          console.error(err);
          alert("Failed to unpublish page. See console.");
        });
    }
  }
</script>
